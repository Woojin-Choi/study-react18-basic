- 리액트 18
  - 원래 되었어야 하는 것들이 기존에 안 되었어서 라이브러리 쓰거나 했는데, 이것들이 기본 기능으로 추가됨.
  - 동시성 강회됨. 서버컴포넌트 등.
- 리액트
  - 10년 정도는 대세일 듯.
  - 한국은 한번 대세가 되면 앞으로 대세일 가능성 높음.
  - 백엔드도 자바보다 노드가 안 좋은게 아님. 그냥 대세일 뿐.
- 왜 SPA가 나왔나?
  - 리액트 뷰 앵귤러 스벨트...
  - 보통 용어가 다르면 다른 역할을 함.
  - 앱같은 느낌이 나는 사이트들을 웹앱.
    - 기능적으로도 프론트에서 다루는 데이터가 많아졌고, 여러 UI를 복잡하게 포현해야 했음. 그러다보니 프론트 개발자가 나온 것. 기존에는 백엔드 개발자가 jquery나 jsp로 구현했었음. 근데 복잡해지다보니 다 하기 버거워서 프론트 개발자가 나온 것.
    - 첫 웹앱이라고 하는 것이 지메일.
    - 웹에서 엑셀 등 다양한 앱들을 돌릴 수 있음. 근데 데이터가 많아서 너무 복잡함.
    - 복잡한 데이터를 바꾸면 화면도 바뀌어야 함. 이게 당연한 듯 보이지만 쉽지 않음. 한 데이터가 바뀌면 다른 데이터도 싹 다 바뀌어야 하는데, 이를 JS로만 하기에는 너무 어려움. 그래서 SPA가 나온 것.
  - 리액트 뷰 등이 해주는 것은, 프론트에서 데이터를 갖고 있고, 데이터가 바뀌면 화면도 바꿔주는 것. 기존에는 이를 JS로만 해야 했는데, 이게 복잡했던 문제를 SPA 라이브러리들이 해결해준 것임.
    - 페이스북이 리액트 만들 때도, 이런 어려움을 겪어서 리액트를 만든 것임.
    - 전통적으로 사용했던 MVC 패턴으로 만들었던 웹사이트를 버리고, FLUX 기반의 리액트를 만들어서 데이터와 화면의 불일치 문제를 해결했음.
  - 리액트, 뷰, 스벨트 들의 차이?
    - 데이터 불일치 문제를 각기 다른 방식으로 해결한 것임.
    - 그 중 리액트가 살아남아 한국에서 대세가 된 것임.
    - 사실 리액트보다 뷰나 스벨트가 사용성이 좋음. 하지만 대세는 리액트
    - 리액트 사이트를 리액트 없이 만들어보는 것을 추천하면서 필요성 느껴보는게 좋다고.
    - 리액트를 배우면 뷰 등은 쉽게 배울 수 있음.
  - 굳이 모든 웹사이트를 SPA로 만들 필요는 없음.
    - 문서 등 단순한 사이트는 jquery로 만들어도 충분함.
    - 그래서 아직도 jquery가 많이 쓰임.
    - 오히려 리액트 단점이 있을 수 있음
      - 순수 JS로만 이루어져서 검색엔진에 불리할 수 있음.
        - 검색엔진 노출 때문에 리액트로 안 만드는 경우도 있음.
        - 미국은 JS 엔진이 좋아서 리액트 사이트도 잘 분석하는데, 네이버나 다음은 리액트로만 이루어진 사이트를 잘 분석하지 못하는 경우 많음.
        - 네이버는 검색엔진이 아니라 포탈이기 때문에 뭔 짓을 해도 잘 안 뜨긴 한다고.
- 프론트의 기본은 JS HTML CSS임
  - 리액트 배운다고 소홀히하기 말기. 꾸준히 하기.
  - 스코프, 실행 콘텍스트 등. 인간 JS 엔진 되기 추천.
- 초반에 마법같은 것을 많이 알면, 기본기가 소홀해지는 경우 많음.
  - 기본기에 중점을 두기 항상.
- 웹 브라우저는 결국 html css js밖에 못 읽음. 리액트도 새로운게 아니라 결국 html css js를 만들어내는 존재일 뿐임.
- 리액트 개발 시 명심할 것
  - 리액트는 JS다
  - 리액트는 **데이터 중심**으로 움직인다.
  - 객체를 막 바꾸지 말기! 불변성 중요. 함수나 배열도 모두 객체임!
    - pop push shift unshift splice -> 배열을 직접 수정
    - concat slice -> 새로운 배열 만들어냄
    - 리액트에서는 위의 것들을 거의 쓰면 안됨.
    - 기존 객체는 놔두고, 이를 복사해서 새로운 객체를 만든 후에, 교체해주기! 이거 교체해주는게 귀찮아서 리액트가 setState 만들어 준 것임.
- 컴포넌트
  - 데이터(state)와 화면(JSX)을 하나로 묶어준 것.
  - 데이터가 바뀌면 화면이 바뀜. 화면에 바뀌는 부분은 state로 만든다.
- 원래는 React.createElement()로 엘리먼트를 작성해줘야 했는데, 이게 너무 불편해서 JSX를 만든 것임.
- script에서 tag를 읽을 수 없음. 근데 리액트에서는 어떻게 코딩을 하나? -> 그래서 나온게 바벨이라는 라이브러리.
  - 바벨이 jsx를 원시적인 코드(createElement)로 바꿔줌.
- react 18에서는
  - root에 넣어주는 reactDom.render 대신에 reactDom.createRoot 방식으로 바뀜.
  - 회사 들어가서 소스코드 보면, 18버전인지 17버전인지 먼저 봐야 함!
- 개발자도구에서 profiler는 성능문제 해결할 때, developer tool은 데이터 볼 때 사용.
- class 에서는 constructor를 안 쓰고 state를 사용하거나, this를 bind() 해서 함수 사용하는 경우도 있었음.
  - this.onClickButton = this.onClickButton.bind(this) 이런 방식으로 해줘야 했음.
  - 위 방식이 불편해서 나온게 화살표 방식. 화살표 함수로 작성하면 bind 하지 않아도 외부 this 사용 가능해서 위 코드 필요 없었음.
- 함수형(X) 함수(O) 컴포넌트
  - 함수형이라고 하면 불편해하는 분들 있음.
  - 코드가 짧아서 좋아함.
  - this 쓸 일이 없어서 좋다고. - **코드를 깔끔하게 짜는 방법은 안 짜면 됨!**
- 리액트 자체는 라이브러리 이지만, 생태게 통틀어서는 프레임워크라고 하기도 함.
- 코드는 거짓말을 안함.
- 구조분해
  - state는 구조분해 할당. 같은 위치에 있는 요소를 바로 변수에 대입해버리는 것임.
  - 객체가 아니라 꼭 배열로 해줘야 함!!
- 리액트에서 document 거의 안 쓰는게 좋음. ref로 사용하는게 좋음. 우리는 리액트를 믿고 데이터만 조작해주면 됨.
  - ref.current.fucus() 방식으로.
- state 바뀔 때마다 render 실행됨. 그래서 함수 밖에서 선언한 후 불러오는 것이 좋음.
- 함수 컴포넌트에서는
  - state가 바뀌면 전체 함수가 다시 실행되어 버림. 그래서 좀 더 느릴 수 있음. 내부 함수들도 다시 생성됨. 나중에 최적화 고려해야 함.
- state를 하나의 객체로 관리해도 되는데, 그러면 setState가 불편해짐. 부분만 바꿀 경우에 나머지 부분들이 삭제되어 버림.
- setState가 함수 내에 연달아 4개 있어도 렌더링은 1회 일어남. 리액트가 알아서 처리해줌. 그래서 setState가 비동기인 것임.
- 웹팩
  - 컴포넌트가 엄청 많은데, 이를 하나의 JS 파일로 합쳐주는 것
  - 하나로 합치면서 바벨도 적용 가능하고, 쓸데없는 코드도 제거할 수 있는 등 유용함
  - 실무에서는 많은 JS 파일로 쪼개지는데, 이를 합쳐줌.
  - 웹팩을 알려면 노드를 알아야 함.
    - 노드는 JS 실행기 그 이상 이하도 아님.
  - 리액트에서는 App.js 로 다 합쳐짐.
  - 최신 문법들을 예전 브라우저에서도 돌아가게 만들어주기도 함. webpach-loader 등 덕분에.
- 파일 확장자는 js, jsx 다 상관 없는데, 내부에 jsx 문법이 있으면 jsx 써주는게 좋음.
- 영어를 모르면 잘하는 개발자는 될 수 있지만, 앞서나가는 개발자는 될 수 없다!

### 추가 공부

- 네이버는 검색엔진이 아니라 포탈
- function, arrow
  - 1. 함수 본연의 기능인 입출력기능을 직관적으로 잘 표현
  - 2. 소괄호 , 중괄호 , return 생략가능
  - 3. 이전 this값 재사용 가능
  - onClick에서 화살표함수를 안쓰고 함수명()을 하면 onClick과 상관없이 바로 실행됨.
- 컴포넌트, 엘리먼트
- mvc, flux
- this, bind(this)
- 함수형, 함수
  - 순수 함수인가?
- 바벨, 웹팩, 비트
-
